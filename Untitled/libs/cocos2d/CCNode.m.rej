***************
*** 63,69 ****
  @synthesize zOrder=zOrder_;
  @synthesize tag=tag_;
  @synthesize vertexZ = vertexZ_;
- @synthesize isRunning=isRunning_;
  
  #pragma mark CCNode - Transform related properties
  
--- 63,69 ----
  @synthesize zOrder=zOrder_;
  @synthesize tag=tag_;
  @synthesize vertexZ = vertexZ_;
+ @synthesize gestureRecognizers = gestureRecognizers_;
  
  #pragma mark CCNode - Transform related properties
  
***************
*** 216,221 ****
  		
  		// userData is always inited as nil
  		userData = nil;
  	}
  	
  	return self;
--- 216,225 ----
  		
  		// userData is always inited as nil
  		userData = nil;
+     
+     // lazy allocation
+     gestureRecognizers_ = nil;
+     isTouchEnabled = NO;
  	}
  	
  	return self;
***************
*** 576,581 ****
  
  -(void) onEnter
  {
  	[children_ makeObjectsPerformSelector:@selector(onEnter)];
  	
  	[self resumeSchedulerAndActions];
--- 580,588 ----
  
  -(void) onEnter
  {
+   if( isTouchEnabled )
+     [self startAllGestureRecognizers];
+   
  	[children_ makeObjectsPerformSelector:@selector(onEnter)];
  	
  	[self resumeSchedulerAndActions];
***************
*** 590,595 ****
  
  -(void) onExit
  {
  	[self pauseSchedulerAndActions];
  	
  	isRunning_ = NO;	
--- 597,604 ----
  
  -(void) onExit
  {
+   [self stopAllGestureRecognizers];
+   
  	[self pauseSchedulerAndActions];
  	
  	isRunning_ = NO;	
***************
*** 691,696 ****
  	[[CCActionManager sharedManager] pauseTarget:self];
  }
  
  #pragma mark CCNode Transform
  
  - (CGAffineTransform)nodeToParentTransform
--- 700,848 ----
  	[[CCActionManager sharedManager] pauseTarget:self];
  }
  
+ #pragma mark Gesture Recognition
+ 
+ -(BOOL) isRunning
+ {
+   return isRunning_;
+ }
+ 
+ -(void) setIsRunning:(BOOL)running
+ {
+   if( isRunning_ != running )
+   {
+     isRunning_ = running;
+     if( isRunning_ && isTouchEnabled )
+       [self startAllGestureRecognizers];
+     else
+       [self stopAllGestureRecognizers];
+   }
+ }
+ 
+ - (void)addGestureRecognizer:(CCGestureRecognizer*)gestureRecognizer
+ {
+   if( ! gestureRecognizers_ )
+ 		gestureRecognizers_ = [[CCArray alloc] initWithCapacity:4];
+   
+   [gestureRecognizers_ addObject:gestureRecognizer];
+   gestureRecognizer.node = self;
+   
+   // if we are running we add the recognizer to the view right now
+   // if not we let the one enter take care of it since we don't
+   // want recognizers going off when the node isn't active
+   if( isRunning_ && isTouchEnabled )
+     [[CCDirector sharedDirector].openGLView addGestureRecognizer:gestureRecognizer.gestureRecognizer];
+ }
+ 
+ - (void)removeGestureRecognizer:(CCGestureRecognizer*)gestureRecognizer
+ {
+   [gestureRecognizers_ removeObject:gestureRecognizer];
+   // this is a sanity check to make sure that someone didn't add the
+   // same gestureRecognizer to different nodes
+   if( gestureRecognizer.node == self )
+     [[CCDirector sharedDirector].openGLView removeGestureRecognizer:gestureRecognizer.gestureRecognizer];
+ }
+ 
+ - (void)stopAllGestureRecognizers
+ {
+   CCGestureRecognizer* recognizer;
+ 	CCARRAY_FOREACH(gestureRecognizers_, recognizer)
+   {
+     if( recognizer.node == self )
+       [[CCDirector sharedDirector].openGLView removeGestureRecognizer:recognizer.gestureRecognizer];
+   }
+ }
+ 
+ -(void) startAllGestureRecognizers
+ {
+   CCGestureRecognizer* recognizer;
+ 	CCARRAY_FOREACH(gestureRecognizers_, recognizer)
+   {
+     if( recognizer.node == self )
+       [[CCDirector sharedDirector].openGLView addGestureRecognizer:recognizer.gestureRecognizer];
+   }
+ }
+ 
+ -(BOOL) isPointInArea:(CGPoint)pt
+ {
+   if( visible_ == NO )
+     return NO;
+   
+   /*  convert the point to the nodes local coordinate system to make it
+    easier to compare against the area the node occupies*/
+   pt = [self convertToNodeSpace:pt];
+   
+   // we have to take the anchor point into account for checking
+   CGRect rect;
+   /*  we should be able to use touchableArea here, even if a node doesn't set
+    this, it will return the contentArea.  */
+   rect.size = self.touchableArea;
+   CGPoint anchor = anchorPoint_;
+   
+   // we pretty much need to undo the anchor to get our rect to start at the lower left
+   anchor.x = 0.5f - anchor.x;
+   anchor.y = 0.5f - anchor.y;
+   
+   rect.origin = CGPointMake( -(rect.size.width*anchor.x), -(rect.size.height*anchor.y) );
+   
+   if( CGRectContainsPoint(rect,pt) )
+     return YES;
+   return NO;
+ }
+ 
+ -(BOOL) isNodeInTreeTouched:(CGPoint)pt
+ {
+   if( [self isPointInArea:pt] )
+     return YES;
+   
+   BOOL rslt = NO;
+   CCNode* child;
+   CCARRAY_FOREACH(children_, child )
+   {
+     if( [child isNodeInTreeTouched:pt] )
+     {
+       rslt = YES;
+       break;
+     }
+   }
+   return rslt;
+ }
+ 
+ -(CGSize) touchableArea
+ {
+   // we use content size if touchable area is 0
+   if( touchableArea_.width != 0.0f ||
+       touchableArea_.height != 0.0f )
+     return touchableArea_;
+   else
+     return contentSize_;
+ }
+ 
+ -(void) setTouchableArea:(CGSize)area
+ {
+ 	touchableArea_ = area;
+ }
+ 
+ -(BOOL) isTouchEnabled
+ {
+ 	return isTouchEnabled;
+ }
+ 
+ -(void) setIsTouchEnabled:(BOOL)enabled
+ {
+   if( isTouchEnabled != enabled )
+   {
+     isTouchEnabled = enabled;
+     CCGestureRecognizer* recognizer;
+     CCARRAY_FOREACH(gestureRecognizers_, recognizer)
+     {
+       // just an extra check
+       if( recognizer.node == self )
+         recognizer.gestureRecognizer.enabled = isTouchEnabled;
+     }
+   }
+ }
+ 
  #pragma mark CCNode Transform
  
  - (CGAffineTransform)nodeToParentTransform
